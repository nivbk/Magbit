<?php

if (!defined('BASEPATH'))
	exit('No direct script access allowed');

include_once('Facebook.php');
include_once('FBIgnitedException.php');

class Fb_ignited {

	/**
	 * Facebook Ignited!
	 *
	 * Do Not Edit This File, Could Cause Disruption of App
	 */
	private $globals;
	public $userid;

	public function __construct($params) {
		/**
		 * This grabs the variables from you config/fb_ignited.php file and
		 * stores them in the globals variable, while passing the below three
		 * to the Facebook SDK when it is called. The instance of CodeIgniter is
		 * set to $this->CI in order to allow usage from the whole class. Additionally
		 * it parses the query strings for the `state` and `code` variables sent to the
		 * app so that there won't be constant redirection.
		 */
		parse_str($_SERVER['QUERY_STRING'], $fb_query_strings);
		if (isset($fb_query_strings['state'])) $_REQUEST['state'] = $fb_query_strings['state'];
		if (isset($fb_query_strings['code']))  $_REQUEST['code']  = $fb_query_strings['code'];
        $this->CI       = & get_instance();
		$fb_params      = $this->fb_set_globals($params);
		$this->facebook = new Facebook($fb_params);
		$this->userid   = $this->facebook->getUser();
	}

	function __call($method, $params) {
		/**
		 * This method is used to make sure that if the method being called from the
		 * class is not present it will then look into the Facebook SDK, check if it exists.
		 * If it does not then it returns a false which the user can use to determine what to do.
		 */
		$this->CI->load->helper('params');
		if (method_exists($this->facebook, $method)) {
			try {
				$value = wrap_call_user_func_array($this->facebook, $method, $params);
			} catch (FacebookApiException $e) {
				throw new FBIgnitedException("Error trying {$method}(): " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
			}
		} else {
			throw new FBIgnitedException("Could not find the method {$method} in Facebook Class.", null, null, $this->globals['fb_logexcept']);
		}

		return $value;
	}

	public function fb_accept_requests($request_ids, $callback = false) {
		/**
		 * This function will handle all your friend requests.
		 * ---
		 * The $callback variable is a holding place for the call of an external model and function.
		 *
		 * Usage: $callback = array('file'=>'fb_requests_mode','method'=>'database_insert');
		 *
		 * file        this is the file that will be called as if you were to use $this->load->model('file');
		 * method    this is the function that will called, eg $this->file->method();
		 *
		 * After the system calls the function it will pass $request_ids to it. Make sure you accept and do with it as
		 * you will.
		 *
		 * Your system must have CURL enabled to utilize this specific method
		 */
		$request_ids = explode(',', $request_ids);
		$result_value = false;
		if ($callback) {
			extract($callback, EXTR_OVERWRITE);
			if ($this->CI->load->model($file)) {
				$this->CI->$file->$method($request_ids);
			}
		}
		foreach ($request_ids as $value) {
			$request_data = $this->facebook->api("/{$value}");
			if ($request_data['from']) {
				$full_request_id = $value . "_" . $this->userid;
				try {
					$result = $this->facebook->api($full_request_id, "DELETE");
				} catch (FacebookApiException $e) {
					throw new FBIgnitedException($e->getMessage(), $e, $this->globals['fb_logexcept']);
				}
				if ($result) {
					if (strlen($result_value) > 0) {
						$result_value .= ", ";
					}
					$result_value .= $request_data['from']['name'];
				}
			}
		}

		return $result_value;
	}

	public function fb_check_permissions($perm, $extend = null) {
		/**
		 * Checks if the permission type enquired about is authenticated and accepted.
		 *
		 * @param $perm - this is the permission that will be checked.
		 * @param $extend - this will tell the function whether or not to extend the users permissions.
		 *     If detected as not null, it will be handled as an array and passed to fb_login_url().
		 */
		try {
			$data = $this->fb_fql("SELECT {$perm} FROM permissions WHERE uid = me()");
		} catch (FBIgnitedException $e) {
			throw new FBIgnitedException("fb_fql() : " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
		}
		$permission = implode(',', array_keys(array_diff($data[0], array(1))));
		if (!$permission) {
			return true;
		} else {
			if ($extend === null) {
				return false;
			} else {
				$extend['scope'] = 'perm';
				$url = $this->fb_login_url($extend);
				if ($extend['script'] == true) {
					echo $url;
					exit;
				} else {
					return $url;
				}
			}
		}
	}

	public function fb_create_event($fb_event_array, $callback = null) {
		$fb_event_utf8 = array_map(utf8_encode, $fb_event_array);
		$param = array(
			'method' => 'event.create',
			'event_info' => json_encode($fb_event_utf8),
			'callback' => $callback
		);
		try {
			$eventID = $this->facebook->api($param);
		} catch (FacebookApiException $e) {
			throw new FBIgnitedException("fb_create_event() - Facebook::api() exception caught: " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
		}

		return $eventID;
	}

	public function fb_feed($method, $id = null, $values = null) {
		if ($method == "post") {
			try {
				$feed_id = $this->facebook->api("/$id/feed", 'post', $values);
			} catch (FacebookApiException $e) {
				throw new FBIgnitedException("fb_feed() - Facebook::api() exception caught: " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
			}
			if (is_numeric($feed_id)) {
				return $feed_id;
			} else {
				throw new FBIgnitedException("fb_feed() - Facebook::api() returned a non-numeric value.", null, $this->globals['fb_logexcept']);
			}
		} elseif ($method == "delete") {
			try {
				$response = $this->facebok->api("/$id", 'delete');
			} catch (FBIgnitedException $e) {
				throw new FBIgnitedException("fb_feed() - Facebook::api() exception caught: " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
			}

			return $response;
		}
	}

	public function fb_fql($fqlquery) {
		/**
		 * This function is a wrapper for fql
		 */
		if (is_array($fqlquery)) {
			$fqlquery = json_encode($fqlquery);
		}
		try {
			$fql_obj = $this->facebook->api(array("method" => "fql.query", "query" => $fqlquery));
		} catch (FacebookApiException $e) {
			throw new FBIgnitedException("fb_fql() - Facebook::api() exception caught: " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
		}

		return json_encode($fql_obj);
	}

	public function fb_get_app($variable = "") {
		/**
		 * If needed we return all of the global configurations.
		 */
		if ($variable != "") {
			if (isset($this->globals[$variable])) {
				return $this->globals[$variable];
			} else {
				return false;
			}
		} else {
			return $this->globals;
		}
	}

	public function fb_get_me($redirect = false, $script = true) {
		/**
		 * This returns all of the information for the user from facebook,
		 * if it can't recieve anything its due to no authorization so refer them
		 * to it.
		 *
		 * @param $script - if set to true will echo out a JavaScript redirect. If set to false will redirect.
		 * @param $redirect - if set to true will cause the user to be redirected to
		 */
		$this->CI->load->helper('url');
		if ($this->userid) {
			try {
				$me = $this->facebook->api('/me');
			} catch (FacebookApiException $e) {
				throw new FBIgnitedException("fb_get_me(): ".$e->getMessage(), $e, $this->globals['fb_logexcept']);
				return false;
			}
			return $me;
		} else {
			if ($redirect == true) {
				$loc = $this->fb_login_url(array('script'=>$script));
				if ($script == true){
					echo $loc;
				} else {
					redirect($loc);
				}
				exit;
			} else {
				return false;
			}
		}
	}

	public function fb_is_bookmarked() {
		try {
			$datas = $this->fb_fql("SELECT bookmarked FROM permissions WHERE uid = me()");
		} catch (FBIgnitedException $e) {
			throw new FBIgnitedException("fb_is_bookmarked(): " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
		}
		if ($datas)
			return true;
		else
			return false;
	}

	public function fb_is_liked() {
		/**
		 * This function checks to see if the user has liked the application or not.
		 */
		try {
			$request = $this->facebook->api("/{$this->userid}/likes/APP_ID");
		} catch (FacebookApiException $e) {
			throw new FBIgnitedException("fb_is_liked() - exception caught: " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
		}
		if ($request['data'] || $request->data)
			return true;
		else
			return false;
	}

	public function fb_list_friends($value = "uid", $list = "") {
		if ($list == "full") {
			$fquery = "SELECT {$value} FROM user WHERE uid IN (SELECT uid2 FROM friend WHERE uid1 = me())";
		} else {
			$fquery = "SELECT {$value} FROM user WHERE uid IN (SELECT uid2 FROM friend WHERE uid1 = me()) AND is_app_user = 'true'";
		}
		try {
			$friends = $this->fb_fql($fquery);
		} catch (FBIgnitedException $e) {
			throw new FBIgnitedException("fb_list_friends(): " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
		}

		return $friends;
	}

	public function fb_login_url($params = null) {
		/**
		 * This method creates a login url that your users
		 * can be redirected towards. If the $script variable is set to true
		 * we also include the javascript to redirect them to the location.
		 */
		if (!isset($params['scope'])) {
			$params['scope'] = $this->globals['fb_auth'];
		}
		if (!isset($params['redirect'])) {
			$params['redirect'] = $this->globals['fb_canvas'];
		}
		$url = $this->facebook->getLoginUrl(array(
			'scope' => $params['scope'],
			'redirect_uri' => $params['redirect']
		));
		if (isset($params['script']) && $params['script'] == true) {
			$url = "<script>top.location.href='" . $url . "'</script>";
		}

		return $url;
	}

	public function fb_logout_url($next = '', $script = false) {
		/**
		 * This method creates a logout url that your users
		 * can be redirected towards. If the $next variable is set
		 * user will be redirect to the $next controller function after the logout process.
		 * $next must be in the declared canvas or end with /
		 */
		$redirect = (substr($this->globals['fb_canvas'], -1) == '/') ? $this->globals['fb_canvas'] . $next : $this->globals['fb_canvas'] . '/' . $next;
		$url = $this->facebook->getLogoutUrl(array(
			'next' => $redirect
		));
		if ($script == true) {
			$url = "<script>top.location.href='" . $url . "'</script>";
		}

		return $url;
	}

	public function fb_notification($message, $user_id = null) {
		if ($user_id === null) {
			$user_id = $this->facebook->getUser();
		}
		$data = array(
			'href' => $this->globals['fb_canvas'],
			'access_token' => $this->facebook->getAccessToken(),
			'template' => $message
		);
		try {
			$send_result = $this->facebook->api("/$user_id/notifications", 'post', $data);
		} catch (FacebookApiException $e) {
			throw new FBIgnitedException("fb_notification() - exception caught: " . $e->getMessage(), $e, $this->globals['fb_logexcept']);
		}

		return $send_result;
	}

	public function fb_post_activity() {

	}

	public function fb_post_to_feed_dialog($display, $link, $picture, $name, $caption, $description) {
		/**
		 * This function will generate a post to feed dialog
		 */
		$tofeed = "<script>
			FB.init({appId: '{$this->globals['fb_appid']}', status: true, cookie: true});
			function postToFeed() {
				var obj = {
					method: 'feed',
					access_token: '{$this->facebook->getAccessToken()}',
					display: '{$display}',
					link: '{$link}',
					picture: '{$picture}',
					name: '{$name}',
					caption: '{$caption}',
					description: '{$description}'
				};
				function callback(response) {
					document.getElementById('msg').innerHTML = 'Post ID: ' + response['post_id'];
				}
				FB.ui(obj, callback);
			}
			postToFeed();
		</script>";

		return $tofeed;
	}

	public function fb_process_credits() {
		$data = array('content' => array());
		$request = $this->facebook->getSignedRequest();
		if ($request == null) {
			throw new FBIgnitedException("Bad signed request in fb_process_credits()", null, $this->globals['fb_logexcept']);
		}
		$me = $this->fb_get_me();
		$payload = $request['credits'];
		$func = $this->CI->input->get_post('method');
		$order_id = $payload['order_id'];
		if ($func == 'payments_status_update') {
			$status = $payload['status'];
			// write your logic here, determine the state you wanna move to
			if ($status == 'placed') {
				$next_state = 'settled';
				$data['content']['status'] = $next_state;
				// If given the go ahead, we finalize the transaction so that the user can grab the item
				$this->CI->db->where('order_id', $order_id);
				$this->CI->db->update('fb_item_cache', array('finalized' => '1'));
			}
			// compose returning data array_change_key_case
			$data['content']['order_id'] = $order_id;
		} else if ($func == 'payments_get_items') {
			// remove escape characters
			$order_info = stripcslashes($payload['order_info']);
			$item_info = json_decode($order_info, true);
			if ($item_info != "") {
				// If the item id is not null we look up the info from the database
				$this->CI->db->select('title, price, description, image_url, product_url')->from('fb_item_store')->where(array('item_id' => $item_info));
				$query = $this->CI->db->get();
				// Add it to the item array so that the system can pull it
				$item = $query->row_array();
				// Then we add a transaction to the item cache.
				$data = array(
					'userid' => $me['id'],
					'item_id' => $item_info,
					'order_id' => $order_id,
					'finalized' => 0,
					'time' => time()
				);
				$this->CI->db->insert('fb_item_cache', $data);
			}
			//for url fields, if not prefixed by http:,
			//prefix them
			$url_key = array('product_url', 'image_url');
			foreach ($url_key as $key) {
				if (substr($item[$key], 0, 7) != 'http://') {
					$item[$key] = 'http://' . $item[$key];
				}
			}
			$data['content'] = array($item);
		}
		$data['method'] = $func;

		return json_encode($data);
	}

	public function fb_request_dialog($display, $message) {
		/**
		 * This function will generate a request dialog
		 */
		$send = "<script>
			FB.init({appId: '{$this->globals['fb_appid']}', frictionlessRequests: true,});
			function sendrequest() {
				FB.ui({
					method: 'apprequests',
					access_token: '{$this->facebook->getAccessToken()}',
					display: '{$display}',
					message: '{$message}'
				}, requestCallback);
			}
			function requestCallback(response) {}
			sendrequest();
		</script>";

		return $send;
	}

	public function fb_send_dialog($display, $link, $picture, $name, $to, $description) {
		/**
		 * This function will generate a send message dialog
		 */
		$send = "<script>
			FB.init({appId: '{$this->globals['fb_appid']}', xfbml: true, cookie: true});
			FB.ui({
				method: 'send',
				access_token: '{$this->facebook->getAccessToken()}',
				display: '{$display}',
				link: '{$link}',
				picture: '{$picture}',
				name: '{$name}',
				description: '{$description}',
				to: '{$to}'
			});
		</script>";

		return $send;
	}

	private function fb_set_globals($params) {
		/**
		 * This function is designed to run the parameters through a security check
		 * as well as set globals and return an array for the Facebook SDK to use.
		 */
		if (is_numeric($params['fb_appid'])) {
			$param_array['appId'] = $this->globals['fb_appid'] = $params['fb_appid'];
		}
		if (ctype_alnum($params['fb_secret'])) {
			$param_array['secret'] = $this->globals['fb_secret'] = $params['fb_secret'];
		}
		if (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == "on"):$this->globals['protocol'] = "https"; else:$this->globals['protocol'] = "http";
		endif;
		$this->globals['fb_auth'] = $params['fb_auth'];
		$this->globals['fb_apptype'] = $params['fb_apptype'];
		if ($this->globals['fb_apptype'] == 'iframe') {
			$this->globals['fb_canvas'] = $this->globals['protocol'] . "://apps.facebook.com/" . $params['fb_canvas'] . "/";
		} elseif ($this->globals['fb_apptype'] == 'connect') {
			if (preg_match('/^http:\/\//', $params['fb_canvas']) || preg_match('/^https:\/\//', $params['fb_canvas'])) {
				$this->globals['fb_canvas'] = $params['fb_canvas'];
			} else {
				$this->globals['fb_canvas'] = $this->globals['protocol'] . "://" . $params['fb_canvas'] . "/";
			}
		}
		$this->globals['fb_logexcept'] = ($params === false) ? false : true;

		return $param_array;
	}
}